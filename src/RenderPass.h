#ifndef VULKAN_RENDERPASS
#define VULKAN_RENDERPASS

#include <vulkan/vulkan.h>
#include <vector>
#include <concepts>

#include "Attachment.h"
#include "Subpass.h"
#include "LogicalDevice.h"
#include "VulkanException.h"


namespace Vulkan::PipelineOptions { class RenderPass; }


/**
 * @brief A RenderPass is the set of attachments, the way they are used, and the rendering work that is performed using them.
 */
class Vulkan::PipelineOptions::RenderPass {
	public:

		/**
		 * @brief Creates a RenderPass given its Subpass(es) and its BoundAttachment(s).
		 * @details It is of "paramount importance" (°_^) that the bound attachments passed as argument is a superset of the bound attachments used for the creation of the Subpass(es) for this render pass.
		 *			Moreover each bound attachment should have a unique index, and, given N attachments are used, indexes should go from 0 to N-1. BoundAttachment(s) generated by Attachment::prepareAttachments follow this property.
		 * 
		 * @param virtualGpu The LogicalDevice whose pipelines will use this render pass.
		 * @param attachments The attachments used by the render Subpass(es) of this render pass.
		 * @param ...subpasses The Subpass(es) of this render pass.
		 * @tparam S Subpass
		 */
		template<std::same_as<RenderPassOptions::Subpass>... S>
		RenderPass(const LogicalDevice& virtualGpu, const std::vector<RenderPassOptions::Attachment::BoundAttachment>& attachments, const S&... subpasses) : virtualGpu{ virtualGpu } {
			//create the VkAttachmentDescription array
			std::vector<VkAttachmentDescription> attachmentDescriptions;
			for (const auto& attachment : attachments) {
				attachmentDescriptions.push_back(+attachment);
			}

			//create the VkSubpassDescription array and save the subpasses in the vector
			std::vector<VkSubpassDescription> subpassesDescriptions;
			([&subpassesDescriptions, this](RenderPassOptions::Subpass subpass) {
				subpassesDescriptions.push_back(+subpass);
				this->subpasses.push_back(subpass);
				}(subpasses), ...);

			//struct with the options for this render pass
			VkRenderPassCreateInfo renderPassInfo{};
			renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
			renderPassInfo.attachmentCount = attachmentDescriptions.size();
			renderPassInfo.pAttachments = attachmentDescriptions.data();
			renderPassInfo.subpassCount = subpassesDescriptions.size();
			renderPassInfo.pSubpasses = subpassesDescriptions.data();

			if (VkResult result = vkCreateRenderPass(+virtualGpu, &renderPassInfo, nullptr, &renderPass); result != VK_SUCCESS) {
				throw VulkanException("Failed to create render pass!", result);
			}
		}

		RenderPass(const RenderPass&) = delete;
		RenderPass(RenderPass&&) = delete;
		RenderPass& operator=(const RenderPass&) = delete;
		RenderPass& operator=(RenderPass&&) = delete;

		~RenderPass() {
			vkDestroyRenderPass(+virtualGpu, renderPass, nullptr);
		}


		/**
		 * @brief Returns the underlying VkRenderPass object.
		 * 
		 * @return The underlying VkRenderPass object.
		 */
		const VkRenderPass& operator+() const {
			return renderPass;
		}


		/**
		 * @brief Returns the subpasses of this render pass.
		 * 
		 * @return The subpasses of this render pass.
		 */
		RenderPassOptions::Subpass getSubpass(unsigned int i) const {
			return subpasses[i];
		}

	private:
		VkRenderPass renderPass;
		const LogicalDevice& virtualGpu;
		std::vector<RenderPassOptions::Subpass> subpasses;
};


#endif

